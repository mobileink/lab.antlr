parser grammar cljParser ;

options { tokenVocab = cljLexer; }

// use an empty start production to exercise the lexer only,
// without triggering parse rule violations
start : sexp+ EOF ;

    // : ( kw | sym ) (kw | sym)* EOF
    // ;

sexp : lexp | vexp | mexp ;

lexp
    : LPAREN (kw | sym | sexp) (sexp | kw | sym | Literal)* RPAREN
    ;

vexp
    : LBRACK (sexp | kw | sym | Literal)+ RBRACK
    ;

mexp
    : LBRACE pair+ RBRACE
    ;

pair: (sexp | kw | sym | Literal) (sexp | kw | sym | Literal) ;

sym
    // : id_ns? id_nm
    : (sym_ns SLASH)? sym_nm
        {
            if ($sym.text.indexOf("::", 1) >= 0)
                {
                    notifyErrorListeners("EXCEPTION: parser: embedded '::' in '"
                                         + $sym.text
                                         + "'");
                }
            if ($sym_ns.text!=null) {
                if ($sym_ns.text.endsWith(":")) {
                    notifyErrorListeners("EXCEPTION parser: trailing ':' in '"
                                         + $sym_ns.text
                                         + "'");
                }}
            if ($sym_nm.text!=null) {
                if ($sym_nm.text.endsWith(":")) {
                    notifyErrorListeners("EXCEPTION parser: trailing ':' in '"
                                         + $sym_nm.text
                                         + ";");
                }}
        }
    ;

kw
    : KW_SENTINEL (kw_ns SLASH)? kw_nm
        {
            if ($kw.text.indexOf("::", 1) >= 0)
                {
                    notifyErrorListeners("EXCEPTION: parser: embedded '::' in '"
                                         + $kw.text
                                         + "'");
                }
            if ($kw_ns.text!=null) {
                if ($kw_ns.text.endsWith(":")) {
                    notifyErrorListeners("EXCEPTION parser: trailing ':' in '"
                                         + $kw_ns.text
                                         + "'");
                }}
            if ($kw_nm.text!=null) {
                if ($kw_nm.text.endsWith(":")) {
                    notifyErrorListeners("EXCEPTION parser: trailing ':' in '"
                                         + $kw_nm.text
                                         + ";");
                }}
        }
    ;

kw_ns: KW_NS ;
kw_nm: KW_NM ;
//id : ID ;
sym_ns: SYM_NS ;
        // {if ($ID.text.startsWith(":"))
        //     $type=ID_KW;}

sym_nm: SYM_NM;


// nb: the lexer still recognizes the individual tokens, but the tree
// walkers generated by ANTLR just pass the parser rule class and do
// not expose a callable method per lexical token type.  if you want
// something like that, define a parser rule with only one
// possibility, as in the rule here for defmulti, which will generate methods enterDefmulti, exitDefmulti, and visitDefmulti:
//defmulti : DEFMULTI;

// so if we want to reserve special treatment for defining forms, we
// could do something like the def production above

