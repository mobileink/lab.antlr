parser grammar cljParser ;

options { tokenVocab = cljLexer; }

// use an empty start production to exercise the lexer only,
// without triggering parse rule violations
start
    : ( kw | sym ) (ws (kw | sym))* ws* EOF
    ;

// to test specific lex rules, define parser rules for them and then
// put them in the start production as desired
// start: (def | special | macro )+ EOF ;


// every parser rule generates enter and exit methods in the Listener
// class, and visit methods in the Visitor class.

// so if you want to pick out some class of symbols or whatever for
// special treatment, you must name it and define a parser rule by
// that name.  that will cause enter/exit/visit methods to be
// generated, which your code can override.

// these parser rules are for test purposes only
// def : DEF | DEFN_ | DEFMACRO | DEFINLINE | DEFN
//     | DEFMULTI | DEFMETHOD | DEFONCE | DEFSTRUCT;

// special: DO | DEF | LET | LOOP ;
// macro : DEFMACRO | DEFINLINE | MACROEXPAND | AND | OR | WHEN ;

ws: WS ;

sym
    // : id_ns? id_nm
    : (sym_ns SYM_SEP)? sym_nm
        {
            if ($sym.text.indexOf("::", 1) >= 0)
                {System.out.println("EXCEPTION: embedded '::' in "
                                    + $sym.text);}
            if ($sym_ns.text!=null) {if ($sym_ns.text.endsWith(":"))
                    {System.out.println("EXCEPTION: terminal ':' in "
                                        + $sym_ns.text);}}
            if ($sym_nm.text!=null) {if ($sym_nm.text.endsWith(":"))
                    {System.out.println("EXCEPTION: terminal ':' in "
                                        + $sym_nm.text);}}
        }
    ;

kw
    : KW_SENTINEL (kw_ns KW_SEP)? kw_nm
        {
            if ($kw.text.indexOf("::", 1) >= 0)
                {System.out.println("EXCEPTION: embedded '::' in "
                                    + $kw.text);}
            if ($kw_ns.text!=null) {if ($kw_ns.text.endsWith(":"))
                    {System.out.println("EXCEPTION: terminal ':' in "
                                        + $kw_ns.text);}}
            if ($kw_nm.text!=null) {if ($kw_nm.text.endsWith(":"))
                    {System.out.println("EXCEPTION: terminal ':' in "
                                        + $kw_nm.text);}}
        }
    ;

kw_ns: KW_NS ;
kw_nm: KW_NM ;
//id : ID ;
sym_ns: SYM_NS ;
        // {if ($ID.text.startsWith(":"))
        //     $type=ID_KW;}

sym_nm: SYM_NM;


// nb: the lexer still recognizes the individual tokens, but the tree
// walkers generated by ANTLR just pass the parser rule class and do
// not expose a callable method per lexical token type.  if you want
// something like that, define a parser rule with only one
// possibility, as in the rule here for defmulti, which will generate methods enterDefmulti, exitDefmulti, and visitDefmulti:
//defmulti : DEFMULTI;

// so if we want to reserve special treatment for defining forms, we
// could do something like the def production above

