grammar testParser ;

// we only need this in order to run org.antlr.v4.runtime.misc.TestRig,
// which needs a parser and start rule

// to test a lexer only you can use org.mobileink.antlr.lex

// import whichever lexer you want to test, also ws
// import idLexer ;
import literals ;

// @lexer::members { // add members to generated symParser
//             public static final int WHITESPACE = 3;
//             public static final int COMMENTS = 5;
//             public static final String stops = " \t\n";
// }


// use an empty start production to exercise the lexer only,
// without triggering parse rule violations
start:  ;

// to test specific lex rules, define parser rules for them and then
// put them in the start production as desired
// start: (def | special | macro )+ EOF ;


// every parser rule generates enter and exit methods in the Listener
// class, and visit methods in the Visitor class.

// so if you want to pick out some class of symbols or whatever for
// special treatment, you must name it and define a parser rule by
// that name.  that will cause enter/exit/visit methods to be
// generated, which your code can override.

// these parser rules are for test purposes only
def : DEF | DEFN_ | DEFMACRO | DEFINLINE | DEFN
    | DEFMULTI | DEFMETHOD | DEFONCE | DEFSTRUCT;

special: DO | DEF | LET | LOOP ;
macro : DEFMACRO | DEFINLINE | MACROEXPAND | AND | OR | WHEN ;


// nb: the lexer still recognizes the individual tokens, but the tree
// walkers generated by ANTLR just pass the parser rule class and do
// not expose a callable method per lexical token type.  if you want
// something like that, define a parser rule with only one
// possibility, as in the rule here for defmulti, which will generate methods enterDefmulti, exitDefmulti, and visitDefmulti:
//defmulti : DEFMULTI;

// so if we want to reserve special treatment for defining forms, we
// could do something like the def production above

